const n=(n,e,...t)=>({t:n,o:e,i:t.filter((n=>!1!==n)),key:e&&e.key}),e=n=>n.children,t=(t,o,c=o.l||(o.l={}))=>r(n(e,{},[t]),o,c),r=(n,e,t,c)=>{if(n.pop)return o(e,n,t);if(n.t.call){n.u=t.u||{};const o={children:n.i,...n.o},s=n.t(o,n.u,(t=>(Object.assign(n.u,t),r(n,e,n))));return n.p=r(s,e,t&&t.p||{},c),e.l=n}{const r=t.dom||(n.t?document.createElement(n.t):new Text(n.o));if(n.o!=t.o)if(n.t){const{key:e,ref:o,...c}=n.o;o&&(o.current=r);for(const n in c){const e=c[n];if("style"!==n||e.trim)e!=(t.o&&t.o[n])&&n in r?r[n]=e:null!=e?r.setAttribute(n,e):r.removeAttribute(n);else for(const n in e)r.style[n]=e[n]}}else r.data=n.o;return o(r,n.i,t),t.dom&&null==c||e.insertBefore(n.dom=r,e.childNodes[c+1]||null),e.l=Object.assign(t,n)}},o=(e,t,o)=>{const c=o._||[];return o._=t.concat.apply([],t).map(((t,o)=>{const s=t.i?t:n("",""+t),i=c.find(((n,e)=>n&&n.t==s.t&&n.key==s.key&&(e==o&&(o=void 0),c[e]=0,n)))||{};return r(s,e,i,o)})),c.map((n=>{const e=n.p&&n.p.dom||n.dom;e&&e.remove()})),o};export{n as h,e as Fragment,t as render};